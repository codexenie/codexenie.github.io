{"meta":{"title":"codeXenie Rule Page","subtitle":"Coding Helper Rule Blog for Visual Studio","description":null,"author":"CodeScroll","url":"https://github.com/codexenie"},"pages":[],"posts":[{"title":"DOUBLE_FREE","slug":"DOUBLE_FREE","date":"2017-09-07T01:46:58.059Z","updated":"2017-09-07T01:46:58.059Z","comments":true,"path":"DOUBLE_FREE/","link":"","permalink":"https://github.com/codexenie/DOUBLE_FREE/","excerpt":"","text":"Double_Free Prohibit deallocating memory duplication If the deallocated pointer variable is deallocated again, the unexpected memory location can be changed. DescriptionIf the same pointer variable is deallocated twice, the data structure for controlling the memory can be damaged. Due to this damage, the program can be ended or two times memory allocation can return the same pointer. If the memory allocation returns the same value twice and the attacker can control this memory area, he can attack by buffer overflow. example 11234567char* ptr = (char*)malloc (SIZE);...if (abrt) &#123; free(ptr);&#125; ...free(ptr); Generally, the memory duplication deallocation is occurred by the following two reasons. Error condition or exception situation Confused situation which part of program is responsible for memory deallocation. Several duplication deallocation weaknesses are not more complicated than the example, but in certain case, they can be occurred apart from more than hundreds lines or in the other file. A programmer frequently deallocates the global variable in particular twice. Related Link CWE 415: Double Free","categories":[],"tags":[]},{"title":"FREE_STACK","slug":"FREE_STACK","date":"2017-09-07T01:46:58.059Z","updated":"2017-09-07T01:46:58.059Z","comments":true,"path":"FREE_STACK/","link":"","permalink":"https://github.com/codexenie/FREE_STACK/","excerpt":"","text":"Memory_Free_On_Stack_Variable Prohibit invalid size when allocating a memory by malloc When allocating a memory by malloc, the size shall be a valid value. DescriptionThe result of arithmetic operation in program can be bigger than the maximum value of that type or be smaller than the minimum value of that type. If it is used as the size of memory allocation without checking the result value of calculation, it can reference invalid memory. example 11234567void foo()&#123;record_t bar[MAX_SIZE];/* do something interesting with bar */...free(bar);&#125; In the example, if the size of num_imgs is a big number, it can be a value unexpected by a developer due to overflow. alternative 11234567void foo()&#123;record_t *bar = (record_t*)malloc(MAX_SIZE*sizeof(record_t));/* do something interesting with bar */...free(bar);&#125; Using the unexpected value shall be prevented by examining the preceding conditions before using it. Related LInk CWE-590: Free of Memory not on the Heap CERT C MEM34-C. Only free memory allocated dynamically","categories":[],"tags":[]},{"title":"LACK INIT OBJ","slug":"LACK_INIT_OBJ","date":"2017-09-07T01:46:58.059Z","updated":"2017-09-07T01:46:58.059Z","comments":true,"path":"LACK_INIT_OBJ/","link":"","permalink":"https://github.com/codexenie/LACK_INIT_OBJ/","excerpt":"","text":"Copy all parts of an object. You must copy all parts of an object when define copy constructor and copy assignment operator. DescriptionCopying functions should be sure to copy all of an object’s data members and all of its base class parts. Most compiler say nothing about partial copy when define copy constructor and copy assignment operator. example 11234567891011121314151617181920212223242526272829303132333435363738394041class C&#123;public: C(const C&amp; c); C&amp; operator=(const C&amp; rhs);private: int mem1; int mem2;&#125;;C::C(const C&amp; c):mem1(c.mem1) /* not compiant; mem2 is not copyed */&#123;&#125;C&amp; C::operator=(const C&amp; rhs) /* not compiant; mem2 is not copyed */&#123; mem1 = rhs.mem1; return *this;&#125;class D : C&#123;public: D(const D&amp; d); D&amp; operator=(const D&amp; rhs);private: char mem;&#125;;D::D(const D&amp; d) : C(d), mem(d.mem)&#123;&#125;D&amp; D::operator=(const D&amp; rhs)&#123; C::operator=(rhs); mem = rhs.mem; return *this;&#125; Copy constructor and copy assignment operator of class C copy partially member of class C. alternative 1123456789101112131415161718192021222324252627282930313233343536373839404142class C&#123;public: C(const C&amp; c); C&amp; operator=(const C&amp; rhs);private: int mem1; int mem2;&#125;;C::C(const C&amp; c):mem1(c.mem1), mem2(c.mem2) /* compiant; */&#123;&#125;C&amp; C::operator=(const C&amp; rhs) /* compiant */&#123; mem1 = rhs.mem1; mem2 = rhs.mem2; return *this;&#125;class D : C&#123;public: D(const D&amp; d); D&amp; operator=(const D&amp; rhs);private: char mem;&#125;;D::D(const D&amp; d) : C(d), mem(d.mem)&#123;&#125;D&amp; D::operator=(const D&amp; rhs)&#123; C::operator=(rhs); mem = rhs.mem; return *this;&#125; Copy constructor and copy assignment operator of class C must copy whole member of class C. Related Link+ “Effective C++” Third Edition by Scott Meyers.","categories":[],"tags":[]},{"title":"MIS_MATCH_MEM_MAN","slug":"MIS_MATCH_MEM_MAN","date":"2017-09-07T01:46:58.059Z","updated":"2017-09-07T01:46:58.059Z","comments":true,"path":"MIS_MATCH_MEM_MAN/","link":"","permalink":"https://github.com/codexenie/MIS_MATCH_MEM_MAN/","excerpt":"","text":"Mismatched_Memory_Management Prohibit allocating and deallocating dynamic memory not consistent with each other A dynamic memory shall be allocated and deallocated by checking it more clearly than the other component of C/C++ language. DescriptionWhen deallocating a memory allocated dynamically, using inappropriate deallocation function is an undefined behavior. If the memory is not deallocated correctly, the memory can be damaged or the program can be ended.The memory allocation and deallocation shall be executed in pair as the following table. allocation deallocation allocator::allocate() allocator::deallocate() operator new()/new operator delete()/delete operator new/new[] operator delete/delete[] std::malloc(), std::calloc(), std::realloc() std::free() example 1123456789void foo()&#123; BarObj *ptr = new BarObj() /* do some work with ptr here */ ... free(ptr);&#125;...free(ptr); The pointer allocated as a new shall not be deallocated by a free(). alternative 11234567void foo()&#123; BarObj *ptr = new BarObj() /* do some work with ptr here */ ...delete ptr;&#125; It shall be deallocated correctly by a delete. example 212345void f() &#123; int *array = new int[10]; // ... delete array;&#125; The pointer allocated as a new[] shall not be deallocated by a delete. alternative 212345void f() &#123; int *array = new int[10]; // ... delete array;&#125; The pointer allocated as a new[] shall be deallocated surely by delete []. Related Link CWE-762: Mismatched Memory Management Routines CERT C++ MEM31-CPP. Properly deallocate dynamically allocated resources","categories":[],"tags":[]},{"title":"SAME TREE","slug":"MIS_BRACE","date":"2017-09-07T01:46:58.059Z","updated":"2017-09-07T01:46:58.059Z","comments":true,"path":"MIS_BRACE/","link":"","permalink":"https://github.com/codexenie/MIS_BRACE/","excerpt":"","text":"Missed Brace The code does not explicitly delimit a block that is intended to contain 2 or more statements, creating a logic error. DescriptionIn C++, braces are optional for blocks. When the delimiter is omitted, it is possible to insert a logic error in which a statement is thought to be in a block but is not. example 1123456void func(int a)&#123; if(a &gt; 1) a++; a++; /* not compliant */&#125; alternative 112345678void func(int a)&#123; if(a &gt; 1) &#123; a++; a++; /* compliant */ &#125;&#125; Related Link CWE-483: Incorrect Block Delimitation","categories":[],"tags":[{"name":"CWE-483","slug":"CWE-483","permalink":"https://github.com/codexenie/tags/CWE-483/"},{"name":"Incorrect Block Delimitation.","slug":"Incorrect-Block-Delimitation","permalink":"https://github.com/codexenie/tags/Incorrect-Block-Delimitation/"}]},{"title":"REDUNDANT_COND","slug":"REDUNDANT_COND","date":"2017-09-07T01:46:58.059Z","updated":"2017-09-07T01:46:58.059Z","comments":true,"path":"REDUNDANT_COND/","link":"","permalink":"https://github.com/codexenie/REDUNDANT_COND/","excerpt":"","text":"Redundant_Condition Prohibit using a conditional expression having the same result at all times There are conditional expressions which the result is always a true or false in the program. DescriptionIn the program, the conditional expression having always true or false results can be a logic error. This error leads to an unachievable code. example 11234567891011121314uint16_t bad_1307_var1;int8_t bad_1307_var2;/* Always false */if ( bad_1307_var1 &lt; 0U ) /* Not compliant */ .../* Always true */if ( bad_1307_var1 &lt;= 0xffffU ) /* Not compliant */... /* Always true */if ( bad_1307_var2 &lt; 130 ) /* Not compliant */ ... The example is the conditional expression having always true of false results. alternative 11234567891011uint16_t good_1307_var1;int8_t good_1307_var2;if ( good_1307_var1 &gt; 0U ) /* Compliant */...if ( good_1307_var1 &lt; 0xffffU ) /* Compliant */... if ( good_1307_var2 &lt; 120 ) /* Compliant */ ... If the correct conditional expression is used, the logic error can be removed. Related Link CWE-570: Expression is Always False CWE-571: Expression is Always True","categories":[],"tags":[]},{"title":"RETURN REFERENCE","slug":"RETURN-REFERENCE","date":"2017-09-07T01:46:58.059Z","updated":"2017-09-07T01:46:58.059Z","comments":true,"path":"RETURN-REFERENCE/","link":"","permalink":"https://github.com/codexenie/RETURN-REFERENCE/","excerpt":"","text":"don’t try to return a reference when you must return an object. Never return a pointer or reference in function. DescriptionNever return a pointer or reference to a local stack object, a reference to a heap-allocated object, or a pointer or reference to a local static object. If return heap-based objects it is possible to occur memory leak. And local static object are destroyed ath the exit of function. It is not valid on out of function scope. example 112345678910111213141516const char&amp; func1()&#123; char* ch = new char(); return *ch; /* not compiant */&#125;const char&amp; func2()&#123; char* ch = 0; if (ch != 0) &#123; return *ch; &#125; return *ch; /* not compiant */&#125; alternative 112345678910111213141516const char func1()&#123; char* ch = new char(); return ch; /* compiant */&#125;const char func2()&#123; char ch = 0; if (ch != 0) &#123; return ch; &#125; return *ch; /* compiant */&#125; Related Link “Effective C++” Third Edition by Scott Meyers. CWE-562: Return of Stack Variable Address","categories":[],"tags":[{"name":"Effective C++ item 14","slug":"Effective-C-item-14","permalink":"https://github.com/codexenie/tags/Effective-C-item-14/"},{"name":"don't try to return a reference when you must return an object.","slug":"don-t-try-to-return-a-reference-when-you-must-return-an-object","permalink":"https://github.com/codexenie/tags/don-t-try-to-return-a-reference-when-you-must-return-an-object/"}]},{"title":"MIS_OPERATOR","slug":"MIS_OPERATOR","date":"2017-09-07T01:46:58.059Z","updated":"2017-09-07T01:46:58.059Z","comments":true,"path":"MIS_OPERATOR/","link":"","permalink":"https://github.com/codexenie/MIS_OPERATOR/","excerpt":"","text":"comparing instead of assigning The code uses an operator for comparison when the intention was to perform an assignment. DescriptionIn many languages, the compare statement is very close in appearance to the assignment statement; they are often confused. example 1123456789void called(int foo) &#123; foo==1; if (foo==1) printf(\"foo\\n\");&#125;int main() &#123; called(2); return 0;&#125; example 2123456789101112131415161718192021222324252627#define SIZE 50int *tos, *p1, stack[SIZE];void push(int i) &#123; p1++; if(p1==(tos+SIZE)) &#123; // Print stack overflow error message and exit &#125; *p1 == i;&#125;int pop(void) &#123; if(p1==tos) &#123; // Print stack underflow error message and exit &#125; p1--; return *(p1+1);&#125;int main(int argc, char *argv[]) &#123; // initialize tos and p1 to point to the top of stack tos = stack; p1 = stack; // code to add and remove items from stack return 0;&#125; The push method includes an expression to assign the integer value to the location in the stack pointed to by the pointer variable.However, this expression uses the comparison operator “==” rather than the assignment operator “=”. The result of using the comparison operator instead of the assignment operator causes erroneous values to be entered into the stack and can cause unexpected results. Related Link CWE 482: Comparing instead of Assigning","categories":[],"tags":[]},{"title":"VIRTUAL DESTRUCTOR","slug":"VIRTUAL_DESTRUCTOR","date":"2017-09-07T01:46:58.059Z","updated":"2017-09-07T01:46:58.059Z","comments":true,"path":"VIRTUAL_DESTRUCTOR/","link":"","permalink":"https://github.com/codexenie/VIRTUAL_DESTRUCTOR/","excerpt":"","text":"Declare destructors virtual in polymorphic base classess. If base class with a non-virtual destructor, it occured undefined behavior. DescriptionIf delete base class pointer with non-virtual destructor, it happens at runtime is that the derived part of the object is never destroyed. So polymorphic base classes should declare virtual desturctors. If a class has any virtual functions, it should have a virtual destructor. Classes not designed to be base classes or not designed to be used polymorphically should not declare virtual destructors. example 112345678910111213141516171819202122class A&#123;public: A(); ~A(); /* not compliant; destructor is not virtual */&#125;;class B : public A&#123; ~B() &#123; mem = 0; &#125;private: int mem;&#125;;void func()&#123; A* a = new B(); delete a;&#125; If delete A class pointer, it happens at runtime is that destructor of B didn’t called. alternative 112345678910111213141516171819202122class A&#123;public: A(); virtual ~A(); /* compliant; */&#125;;class B : public A&#123; ~B() &#123; mem = 0; &#125;private: int mem;&#125;;void func()&#123; A* a = new B(); delete a;&#125; Destructor of A must be virtual. Related Link “Effective C++” Third Edition by Scott Meyers. CERT C++ OOP52-CPP. Do not delete a polymorphic object without a virtual destructor","categories":[],"tags":[]},{"title":"SAME TREE","slug":"SAME_TREE","date":"2017-09-07T01:46:58.059Z","updated":"2017-09-07T01:46:58.059Z","comments":true,"path":"SAME_TREE/","link":"","permalink":"https://github.com/codexenie/SAME_TREE/","excerpt":"","text":"Never redefine an inherited non-virtual function. Non-virtual functions are statically bound. DescriptionNon-virtual functions are statically bound. It should have the same behavior no matter whether you call the derived function from a pointer to base class or from a pointer to derived class. Otherwise it is not is-a inheritance. example 1123456789101112131415class A&#123; public: void call();&#125;;class B : public A&#123; public: void call(); /* not compliant */&#125;;void func()&#123; A* x = new B(); x-&gt;call(); &#125; alternative 1123456789101112131415class A&#123; public: virtual void call();&#125;;class B : public A&#123; public: void call(); /* compliant */&#125;;void func()&#123; A* x = new B(); x-&gt;call(); &#125; Related Link “Effective C++” Third Edition by Scott Meyers. CERT C++ OOP02-CPP. Do not hide inherited non-virtual member functions","categories":[],"tags":[{"name":"Effective C++ item 36","slug":"Effective-C-item-36","permalink":"https://github.com/codexenie/tags/Effective-C-item-36/"},{"name":"Never redefine an inherited non-virtual function.","slug":"Never-redefine-an-inherited-non-virtual-function","permalink":"https://github.com/codexenie/tags/Never-redefine-an-inherited-non-virtual-function/"}]}]}